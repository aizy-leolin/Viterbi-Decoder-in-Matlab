function dec_num = B2D(bin_num)
%=============================================================================
%	function dec_num = B2D(bin_num)
%
%	Binary to Decimal Conversion
%
%   John O'Shea, joshea@emc.com 
%
%==============================================================================

[nrows,ncols] = size(bin_num);
if ncols==1,
   bin_num = bin_num';
   [nrows,ncols] = size(bin_num);
end;
dec_num = [];
for j=1:nrows,
   num = 0;
   for i=0:ncols-1,
      num = num + bin_num(j,ncols-i)*2^i;
   end;
   dec_num = [dec_num num];
end;
function [R]=BSC_CHANNEL(V,n,N,m,EbN0)
%==============================================================
% [R]=BSC_CHANNEL(V,n,N,m,EbN0)
% 
%  Models a Noisy BSC Channel
%  The decoder will then perform error correction by applying 
%  maximum likelihood decoding on the Received Message R.
%	 
%   John O'Shea, joshea@emc.com 
%==============================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

R = V;

% Model the bit error probaility over a BSC channel.

p=0.5*(erfc(sqrt(2*EbN0)/sqrt(2))); 
%Generate A random message of length of R = N
error=rand(1,length(R));
% Find the symbol positions that are less than the transition probability p
error_pos=find(error<p);
% For every symbol position < p, change the bit in error
for i=1:length(error_pos),
   R(error_pos(i)) = abs(R(error_pos(i))-1); %Change the bit in error
end;




function [bin_num] = D2B(dec_num,m)
%=============================================================================
%	function [bin_num] = B2D(dec_num,m)
%
%	Decimal to Binary Conversion
%
%   John O'Shea, joshea@emc.com 
%
%==============================================================================

[nrows,ncols] = size(dec_num);
if nrows==1,
 dec_num = dec_num';
end;

N = length(dec_num);
M = max(dec_num);
n = nextpow2(M+1);
%bin_num = zeros(N,n);
bin_num = zeros(N,m);

for i=1:m,
 num(:,i) = rem(dec_num,2);
 dec_num  = fix(dec_num./2);
end; 

bin_num = fliplr(num);
function [D] = DISPLAY_BER(U,D,N,i)
%===================================================
%	function [D] = DISPLAY_BER(U,D,N,i)
% 
%	Initialize all data structures
%
%  John O'Shea, joshea@emc.com
%===================================================


%Determine the number of bit errors
num_bit_errors=0;
for j=1:N,
   if xor(U,D)==1;
      num_bit_errors=num_bit_errors+1;
   end;
end;

%Determine bit error rate
bit_error_rate=sum(abs(U(1,1:N)-D(1,1:N)))/N;

str = ('==========================================');
disp(str);

str = sprintf('Pseudo Block =%d',i);
disp(str);

str = sprintf('Number of bit errors = %d,BER = %d',num_bit_errors,bit_error_rate);
disp(str);

str = ('==========================================');
disp(str);

D=[];
function [n,k,m,g,M,bit_errs,D,T,A,P,HD,PPM,U_vectors,NUM_VECTORS,N,EbN0]=INITIALIZE
%====================================================================================
%	function [n,k,m,g,M,bit_errs,D,T,A,P,HD,PPM,U_vectors,NUM_VECTORS,N,EbN0]=INITIALIZE
% 
%	Initialize all data structures
%
%  John O'Shea, joshea@emc.com
%====================================================================================


n=2;k=1;m=3;		
g=[1,0,1,1;1,1,1,1];

% M = Total Encoder memory, M=m for (n,1,m) encoders
M=m; 
bit_errs=0;
D=[];
EbN0=10;
T=(5*m);    
%Initialiaze the Accumulated path metric memory, (A)
A          = zeros(1,2^M);
%Initialiaze the path memory, (P)
P          = zeros(2^M,k*T);
%Initialiaze the Branch Metrics look-up memory, (HD)
HD         = zeros(1,n*(2^M));
%Initialiaze the 2^k partial path metric memory for compare & select, (PPM)
PPM        = zeros(1,2^k);

N=225;
%N=20;
NUM_VECTORS=10;
U_vectors=zeros(NUM_VECTORS,N);
for v=1:10,
   U_vectors(v,:) = ceil(rand(1,N)-0.5);
end;

%U_vectors=[0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0;
%   0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1;
%   0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0;
%   0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1;
%   0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0;
%   0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1;
%   0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0;
%   0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1;
%   1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0;
%   1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0];

function [V] = VIT_ENC(U,n,k,g,N)
%===========================================================
%	function [V] = VIT_ENC(U,n,k,g,N)
% 
%	Implements a convolutional encoder having given 
%  the generator matrix g of the encoder.
%   
%  Reference Digital Communications (B. Sklar) for method 
%	 
%   John O'Shea, joshea@emc.com 
%============================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

[rows,L] = size(g);
m=L-1;
if k==1,
   for i=1:rows,
      code(i,:)=rem(conv(g(i,:),U),2);
   end;
else
   for i=1:k:rows,
      code(i,:)=rem(conv(g(i,:),U(1,:)),2);
      code(i+1,:)=rem(conv(g(i+1,:),U(2,:)),2);
   end;
end;

if k==1,
   for i=1:N+m,
      V((i-1)*n+1:(i-1)*n+n) = code(:,i);
   end;
else
   i=1;
   j=1;
   while i<rows+1,
      codeword(j,:) = xor(code(i,:),code(i+1,:));
      i=i+k;
      j=j+1;
   end;
   for i=1:N+m,
      V((i-1)*n+1:(i-1)*n+n) = flipud(codeword(:,i));
   end;
   %Add on flushing zeros      
   V(length(V)+1:n*(N+m)) = [0];
end;

function [A,P]=bACSU_213(x,k,m,HD,A,P)
%==================================================================
%	function [A,P]=bACSU_213(x,k,m,HD,A,P)
%
%	Trellis stage computation for (2,1,3) backward label decoder
%
%   John O'Shea, joshea@emc.com
%
%==================================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

% Define Trellis State names
st0=0;st1=1;st2=2;st3=3;st4=4;st5=5;st6=6;st7=7;

% Generate copy of Acc for processing
A_copy = A;
%======================
%   State 0 ACS
%======================
[sel_out0, metric_out0]=bACS_213(x,m,HD(1,1),HD(1,9),A_copy(1,(st0+1)),A_copy(1,(st4+1)));

% Update State(000) Metrics
A(1,st0+1) = metric_out0;
P(st0+1,x) = D2B((sel_out0-1),k);

%======================
%   State 1 ACS
%======================
[sel_out1, metric_out1]=bACS_213(x,m,HD(1,2),HD(1,10),A_copy(1,(st0+1)),A_copy(1,(st4+1)));

A(1,st1+1)= metric_out1;
P(st1+1,x) = D2B((sel_out1-1),k);;

      
%======================
%   State 2 ACS
%======================

if x > 1,
   [sel_out2,metric_out2]=bACS_213(x,m,HD(1,3),HD(1,11),A_copy(1,(st1+1)),A_copy(1,(st5+1)));
   % Update State(010) Metrics
   A(1,st2+1)= metric_out2;
   P(st2+1,x) = D2B((sel_out2-1),k);
end   

%======================
%   State 3 ACS
%======================

if x > 1,
   [sel_out3,metric_out3]=bACS_213(x,m,HD(1,4),HD(1,12),A_copy(1,(st1+1)),A_copy(1,(st5+1)));
   % Update State(011) Metrics
   A(1,st3+1)= metric_out3;
   P(st3+1,x) = D2B((sel_out3-1),k);
end

%======================
%   State 4 ACS
%======================

if x > 2,
   [sel_out4,metric_out4]=bACS_213(x,m,HD(1,5),HD(1,13),A_copy(1,(st2+1)),A_copy(1,(st6+1)));
   % Update State (100) Metrics
   A(1,st4+1)= metric_out4;
   P(st4+1,x) = D2B((sel_out4-1),k);
end;

%======================
%   State 5 ACS
%======================

if x > 2,
   [sel_out5, metric_out5]=bACS_213(x,m,HD(1,6),HD(1,14),A_copy(1,(st2+1)),A_copy(1,(st6+1)));
   % Update State(101) Metrics
   A(1,st5+1) = metric_out5;
   P(st5+1,x) = D2B((sel_out5-1),k);
end;

%======================
%   State 6 ACS
%======================

if x > 2,
   [sel_out6, metric_out6]=bACS_213(x,m,HD(1,7),HD(1,15),A_copy(1,(st3+1)),A_copy(1,(st7+1)));
   % Update State(110) Metrics
   A(1,st6+1) = metric_out6;
   P(st6+1,x) = D2B((sel_out6-1),k);
end;

%======================
%   State 7 ACS
%======================

if x > 2,
   [sel_out7, metric_out7]=bACS_213(x,m,HD(1,8),HD(1,16),A_copy(1,(st3+1)),A_copy(1,(st7+1)));
   % Update State(111) Metrics
   A(1,st7+1) = metric_out7;
   P(st7+1,x) = D2B((sel_out7-1),k);
end;
function [sel_out, metric_out]  =bACS_213(x,m,HD_in1,HD_in2,A_in1,A_in2)
%============================================================================================
%	function [sel_out,metric_out]=bACS_213(x,m,HD_in1,HD_in2,A_in1,A_in2)
%
%	Add-Compare-Select function for (2,1,3) decoder
%
%   John O'Shea, joshea@emc.com
%
%============================================================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

if x <= m,
   metric_out = A_in1 + HD_in1;
   sel_out = 1;
else
   %ADD
   PPM(1,1) = A_in1 + HD_in1;
   PPM(1,2) = A_in2 + HD_in2;
   %COMPARE
   [minmetric,sel] = min(PPM);
   %Select
   sel_out=sel;
   metric_out = minmetric;
end;
   
function [HD]=bBMU_213(Rx)
%======================================================
%	function [HD]=bBMU_213(Rx)
%
%	Branch Metric Unit for (2,1,3) decoder
%   - Look Up Branch Metrics (Hamming distance)
%     for entire trellis stage
%
%   John O'Shea, joshea@emc.com 
%
%======================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

Rxd=b2d(Rx);

if Rxd==0,
   HD=[0,2,1,1,2,0,1,1,2,0,1,1,0,2,1,1];

elseif Rxd==1,
   HD=[1,1,0,2,1,1,2,0,1,1,2,0,1,1,0,2];
   
elseif Rxd==2,
   HD=[1,1,2,0,1,1,0,2,1,1,0,2,1,1,2,0];
   
else,
   HD=[2,0,1,1,0,2,1,1,0,2,1,1,2,0,1,1];
   
end;   

function [min_metric,tb_ptr]=bTBDECISION_213(A)
%===========================================================
% function [minmetric,tb_ptr]=bTBDECISION_213(A)
%
%	Traceback Decision Unit for (2,1,3) decoder
%
%   - Determine pointer to initial state for traceback
%     by finding the state with minimum accumulated metric
%
%   John O'Shea, joshea@emc.com 
%
%===========================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

[min_metric,tb_ptr] = min(A);
% Decrement to adjust for actual state
tb_ptr=tb_ptr-1;




function [D]= bTRACEBACK_213(P,A,m,D,N,T,x)
%=================================================
%   function [D]= bTRACEBACK_213(P,A,m,D,N,T,x)
%
%   (2,1,3) Backward Label Traceback Function
%
%	 Returns D, The Decoded Message up to stage x
%
%   John O'Shea, joshea@emc.com,
%=================================================

if nargin==0, 
   error('Not enough input arguments.');
end;
% Find Traceback start state
[min_metric,tb_ptr]=bTBDECISION_213(A);
% Perform Traceback process
if x<=N+m,
   for stage_ptr = T : -1: 2,
      if stage_ptr == T,
         Bx=B2D(P((tb_ptr+1),stage_ptr));
         Sx=D2B(tb_ptr,m);
      else
         Sx_1=B2D(Sx_1);
         Bx=B2D(P((Sx_1+1),stage_ptr));
         Sx=D2B(Sx_1,m);
      end;
      Sx_1=[Bx Sx(1,1) Sx(1,2)];
   end;
   % Find Decoded Symbol, Dx
   Dx    =[Sx_1(1,m)];
   % Add Decoded Symbol to Maximum Likelihood path, D
   D     =[Dx D];
else
   % At stage x=N, there are no more partial path metrics 
   % to be added, decode the remaining ML path symbols, Dx, 
   % that reside in path memory
   %i=N+m-length(D);
   %while i>0,
      for stage_ptr = T: -1 : 2,
         if stage_ptr == T,
            Bx=B2D(P((tb_ptr+1),stage_ptr));
            Sx=D2B(tb_ptr,m);
         else
            Sx_1=B2D(Sx_1);
            Bx=B2D(P((Sx_1+1),stage_ptr));
            Sx=D2B(Sx_1,m);
         end;
         Sx_1=[Bx Sx(1,1) Sx(1,2)];
      end;
      % Find Decoded Symbol, Dx
      Dx    =[Sx_1(1,m)];
      % Add Decoded Symbol to Maximum Likelihood path, D
      D     =[Dx D];
   end;
   
   
   
   




   
function bTRELLIS_213(Ux_,MLDpath,tr_hist,n,k,m,N)
%===================================================================================
%	function bTRELLIS_213(Ux_,MLDpath,tr_hist,n,k,m,N)
%
%	1. Plot the trellis survivors
%  
%  2. Plot the final surviving MLD path
%
%	3. Plot the decoded bit stream 
%	
%   John O'Shea, joshea_john@emc.com
%===============================================================================

if nargin==0, 
   error('Not enough input arguments.'); 
end;

figure;
subplot(211);

x = 1:N+m+1;y = 0:2^m-1;

for i=1:N+m+1,
   for j=1:2^m,
     plot(x(i),y(j),'k.');%plot all states over time
     hold on;
   end;
end;
axis([0 N+m+2 -1 2^m]);
xlabel('(2,1,3) Efficient Backward Label Decoder survivors and M.L.D. path');
   
%  Plot for first L-1 levels
cs=0; ns=[];

for t=1:m,
   for i=1:length(cs),
      for j=1:2^k,
         ns(1,j)=nsTable(cs(i)+1,j);
         x = [t t+1];y = [2^m-(cs(i)+1) 2^m-(ns(1,j)+1)];
         plot(x,y,'c-');
         hold on;
      end;
   end;
   y = [(2^m-(MLDpath(t)+1)) (2^enc_mem-(MLDpath(t+1)+1))];
   plot(x,y,'r-');
   hold on;
   if t==1,
      cs=[ns];ns = [];
   else
      cs = [cs ns];ns=[];
   end;
end;

%   Plot for central part of trellis
t=N+m;
cs=0; ns=[];
while t>m,
   for s=1:2^m,
      cs=trellishistory(s,t);
      for j=1:2^k,
         ns(1,j)=nsTable(1,j);
         x = [t t+1];
         y = [2^m-(cs+1) 2^m-s];
         plot(x,y,'c-');
         hold on;
      end;
   end;
   y = [(2^m-(MLDpath(t)+1)) (2^m-(MLDpath(t+1)+1))];
   plot(x,y,'r-');
   hold on;
   t=t-1;
end;


%Plot decoded bit stream
subplot(212);
x = 1:length(Ux_)+1; y = 0:1;

for i=1:length(Ux_)+1,
  for j=1:2,
    plot(x(i),y(j),'');
    hold on;
 end;
end;
axis([0 length(Ux_)+2 -1 2]);
xlabel ('Efficient Backward Label Viterbi Decoder output bit stream');

for t=1:length(Ux_),
   if t==1,
      if Ux_(t)==0,
        x = [t t+1]; y = [0 0];
        plot(x,y,'r-');
        hold on;
     elseif Ux_(t)==1,
        x = [t t+1]; y = [1 1];
        plot(x,y,'r-');
        hold on;
      end;
   elseif t~=1,
      if Ux_(t-1)==1 & Ux_(t)==0,
        x = [t t]; y = [1 0];
        plot(x,y,'r-');
        hold on;
        x = [t t+1]; y = [0 0];
        plot(x,y,'r-');
        hold on;
      elseif Ux_(t-1)==1 & Ux_(t)==1,
        x = [t t+1];y = [1 1];
        plot(x,y,'r-');
        hold on;  
      elseif Ux_(t-1)==0 & Ux_(t)==1,
        x=[t t];y=[0 1];
        plot(x,y,'r-');
        hold on;
        x = [t t+1];y = [1 1];
        plot(x,y,'r-');
        hold on;
      elseif Ux_(t-1)==0 & Ux_(t)==0,
        x = [t t+1];y = [0 0];
        plot(x,y,'r-');
        hold on;  
      end;
   end;  
end;
hold off;

%============================================================================
%  bVITERBI_213.m 
%  (2,1,3)Backward Label Viterbi Decoder.
%
%  This MATLAB routine performs forward error correction using the
%  Viterbi decoding algorithm on the Message based on hard decisions.
%
%  The convolutional encoded block size = 456 bits
%  The Channel Model is Binary Symmetric
%  Ten 456-bit randomly generated pseudo blocks are generated to test
%  the decoding process
%
%   John O'Shea, joshea@emc.com
%===========================================================================
clear;
[n,k,m,g,M,bit_errs,D,T,A,P,HD,PPM,U_vectors,NUM_VECTORS,N,EbN0]=INITIALIZE;
           
%==== Cycle through each 20-bit pseudo block ====           
for i=1:NUM_VECTORS,
   %Read current N bit pseudo block
   [U]=U_vectors(i,:);
   % Generate V, (Convolutional Encoded Message) for transmission 
   V = VIT_ENC(U,n,k,g,N);
   % Inject bit errors in to, V, to form the received message, R.
   [R]=BSC_CHANNEL(V,n,N,m,EbN0);
   %============= Processing the algorithm =================
   x=1;% Set trellis stage to 1
   while N >length(D),
      %Determine the n-bit symbol, Rx, from the message, R, at the current stage
      if x<=N+m,
         Rx=R(n*(x-1)+1:n*x);
      end;
      %Determine all Branch Metrics for, Rx, at the current stage
      [HD]=bBMU_213(Rx);
      
      if (x <= T),
         %Calculate the partial path metrics and backward labels at stage x
         [A,P]=bACSU_213(x,k,m,HD,A,P);
      elseif (x <= N+m)
         % Perform traceback read & output an symbol, Dx, for one decoded stage
         [D]= bTRACEBACK_213(P,A,m,D,N,T,x);
         % Shift window k stage's left for next set of path descisions 
         P(:,1:T) = [P(:,2:T) P(:,T)];
         %Calculate partial path metrics and backward labels at stage x
         [A,P]=bACSU_213(T,k,m,HD,A,P);
      else
         % Perform traceback read on the remaining n-bit symbols
         [D]= bTRACEBACK_213(P,A,m,D,N,T,x);
         % Shift window k stage's left for next set of path descisions 
         P(:,1:T) = [P(:,2:T) P(:,T)];
      end;
      x=x+1; %Increment stage pointer
   end;
   % Perform bit reversal on the decoded message, D
   D=fliplr(D);
   [D] = DISPLAY_BER(U,D,N,i);
end;





